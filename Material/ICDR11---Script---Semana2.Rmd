---
title: "ICDR11 - Script - Semana2"
author: "Kassuga.AD"
date: "21/11/2020"
output:
  pdf_document:
    toc: yes
  html_document:
    highlight: textmate
    theme: flatly
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: no
---


# Semana 2 - Comandos Básicos

**Lembre-se de sempre indicar o diretório de trabalho e os pacotes que vocÊs vão utilizar no inicio dos Script**
  
Indicando o diretório de trabalho
```{r, Definindo diretorio de trabalho, eval = FALSE }
setwd("D:/.../curso_r/dados")
```

Abrindo os pacotes necessários
```{r, Abrindo os pacotes necessarios}
library(MASS)
library(tibble)
library(magrittr)
```

## Recapitulando a semana passada

Esta semana vamos continuar nosso estudo sobre a linguagem R.  
  
Recapitulando a semana passada, nós aprendemos os seguintes tópicos: 

* Introdução a ciência de dados com o R  
* Formas de obter ajuda  
* Console vs Script  
* Uso de comentários  
* Definindo a pasta de trabalho  
* Os pacotes  
* O R como calculadora  
* O Rstudio  
* Trabalhando com objetos  
    + Defindo objetos ("<-") - **ALT + "-"**  
    + Nomeando objetos  
    + Trabalhando com vetores  
    + Extraindo valores de vetores  
    + Controlando seu ambiente de trabalho  
    + Primeiras funções

Nós utilizamos as seguintes funções:

* `setwd()` Define o diretório de trabalho
* `getwd()` Descobre em qual diretório de trabalho estamos
* `list.files()` Lista todos os arquivos dentro do diretório de trabalho
* `install.packages()` Instala pacotes
* `<-` Sinal de atribuicao
* `mode()` Descobre o modo do vetor
* `ls()` Lista os objetos no ambiente de trabalho
* `sum()` Soma todos os valores do vetor
* `sample()` Amostra valores dentro do vetor
* `sort()` Retorna os valores do vetor em ordem crescente ou decrescente
* `order()` Retorna os postos dos elementos do vetor
* `:` Cria uma sequencia de inteiros
* `seq()` Cria uma sequencia com parâmetros
* `rep()` Cria uma repetição
* `runif()` Cria uma sequencia aleatória
* `mean()` Calcula a media do vetor
* `sd()` Calcula o desvio-padrao do vetor


## Assuntos dessa semana  

Esta semana vamos aprender os tipos de dados que o R utiliza, bem como as estruturas em que podemos organizar nossos dados. Ainda, vamos aprender o que são condicionais e loops, e quando podemos utiliza-los para agilizar nosso código.


## Operador Pipe

Antes de conhecermos melhor os tipos de dados utilizados pelo R e as estruturas que podem ser organizados, vamos conhecer um novo operador que vai facilitar muito nosso fluxo de trabalho. O operador pipe ` %>% `.  Dica: para acessar o pipe mais facil no RStudio, o atalho é **CTRL + SHIFT + M**.
O pipe foi introduzido no pacote `magrittr`, mas ja esxistem diversos pacotes que o utilizam. Por exemplo o conjunto `tidyverse`.  
Para vermos a praticidade do ` %>% `, podemos utilizar um exemplo do exercicio 1.  

* Exemplo do Exercicio 1
    - Escolha um numero
    - Some 2
    - Multiplique o resultado por 3
    - Subtraia 6 do resultado
    - Divida o resultado por 3
    - Compare o resultado com o seu número inicial

```{r relembrando exercicio}
x <- 25 # escolha o numero que preferir

x2 <- x+2
x2 <- x2*3
x2 <- x2-6
x2 <- x2/3

x2==x
```

Podemos tambem realizar de outra forma, utilizando funções aritméticas ao invés de operadores. Estas funções estão contidas no pacote `magrittr`.  

```{r usando as funcoe sdo magrittr}
x <- 25

x2 <- add(x, 2)
x2 <- multiply_by(x2,3)
x2 <- subtract(x2, 6)
x2 <- divide_by(x2, 3)

x2==x
```
  
Mas vamos lembrar que podemos executar funções sobre funções para reduzir o código. Repare que neste código estamos executando na mesma linha todos os cálculos e ainda estamos realizando um teste lógico para verificar se o valor inicial de `x` é o mesmo do novo valor calculado utilizando o operador lógico `==`.  

```{r juntando funcoes}
x==divide_by(subtract(multiply_by(add(x,2), 3), 6), 3)
```

Agora vamos ver como ficaria utilizando o operador pipe.

```{r pipeando o exe}
x2 <- x %>% 
  add(2) %>% 
  multiply_by(3) %>% 
  subtract(6) %>% 
  divide_by(3) 

x2==x
```
  
  Ficou muito mais facil ler o código utilizando pipe. Mais para frente, vamos utilizar bastante o operador pipe para facilitar a manipulação dos dados.
  
  
## Tipos de dados  

A forma mais simples de armazenar dados no R é com vetores atômicos.Nós criamos vetores na semana passada utilizando o sinal de atribuição `<-`. Os vetores podem possuir somente um valor (escalares) ou vários valores.   
Para reconhecermos o tipo de dado, utilizamos a função `typeof()`.  
Vamos conhecer agora os seis tipos de vetores atômicos.  

### Doubles  

* Números regulares
* Positivos, negativos, grandes ou pequenos
* Com casas decimais
```{r criando doubles}
db <- c(1, 2, 3)
db
typeof(db)

db2 <- c(1.5, 2, 3)
db2 
typeof(db2)
```

### Integers
* Números inteiros
* Cientistas de dados não vão utilizar, podem ser armazenados como “doubles”

```{r criando integers}
int <- 1:3 
# ou 
int<- c(1L, 2L, 3L)
int 
typeof(int)
```

### Characters
* Armazenam pequenos pedaços de texto
* Criados utilizando “ ”

```{r criando character}
text <- c("Hello", "World")
text 
typeof(text)
```

### Logicals
* Armazena valores TRUE e FALSE
* Forma booleana do R
* Ajudam a fazer comparação

```{r criando logicals}
2 < 6
logico<- c(TRUE, FALSE, TRUE)
logico
typeof(logico)
```

### Complexos
* Números complexos
* Pouco provável de ser utilizado

```{r criando complex}
nc  =  2 + 3i
nc
typeof(nc)
```

## Estruturas
  
O R trabalha com diferentes tipos de estruturas

![estruturas de dados](img/estrutura_r.png){ width=65% }


### Vetores  

* Os vetores são as estruturas mais simples do R
    + Podem ter um único valor (escalar)
    + ou múltiplos
    + Todos devem ser do mesmo tipo
    
    
```{r, escalar}
x <- 10
x
```

```{r vetor com multiplos valores}
x <- c(1, 2, 3)
x
```
    
```{r, nomeando valores}
names(x) = c("sp1", "sp2", "sp3")
x
```

* Podemos transformar vetores em objetos de n-dimencoes utilizando a funcao `dim()`

```{r}
x <- 1:6
dim(x) <- c(2,3)
x
```


### Matrizes  

* Matrizes armazenam dados em duas dimenções
     + Dados organizados em linhas x colunas
     + Dados de um único tipo
         - Numéricos, lógicos,...
     + Muito importante para análises multivariadas
     + Podemos nomear linhas e colunas

```{r, criando matrizes}
x  <- c (1:12)
xmat  <-  matrix(x, ncol = 4) 
xmat
```

O parâmetro `byrow` indica se deve montar a matriz com os valores por linhas ou por colunas  
```{r matriz por linhas}
matrix(x, byrow = T)
```
  

Ja o parâmetro `nrow` indica quantas linhas a matriz vai ter  
```{r por colunas}
matrix(x, nrow=3, byrow = F)
```
  
Podemos buscar valores dentro da matriz utilizando `[,]`

```{r encontrando valores}
xmat[2,3]
```
  
Utilizando `colnames()` e `rownames()` podemos nomear as colunas e as linhas, respectivamente:

```{r nomeando matriz aij}
colnames(xmat)=c("sp1","sp2","sp3","sp4")
rownames(xmat)=c("porcos","abobrinha","maramuta")

xmat
```


### Array


### Classes

* Mudar o número de dimensões não muda o tipo de objeto
* Mas modifica sua classe


```{r classes}
x <- 1:6
dim(x) <- c(2,3)

typeof(x)
class(x)
```



### Lista  

* Semelhantes a vetores
* Agrupam dados em organização unidimensional
* Não agrupam valores individuais
* Agrupam objetos
    + Vetores
    + Outras listas


```{r criando listas}
lista1 <- list(1:10, "R", list(TRUE, FALSE))
lista1
lista2 <- list(a = c(1:10), b = c(11:20))
lista2
```

* Podemos aplicar funções `apply()` em listas
    + `sapply`Realiza uma função em uma lista ou data frame
    + `lapply()`retorna o resultado em forma de lista

```{r saplicando em listas}
sapply(lista2, sum)
```

```{r laplicando em listas}
lapply(lista2, sum)

```


### Data frame  
  
* Versão bidimensional da lista
* Dados organizados em linhas e colunas
* Dados de tipos diferentes
* Cada coluna deve conter o mesmo tipo de dado
* Cada linha é uma "observação"
* Vamos utilizar com mais frequência nas nossas análises
  
Primeiro criamos o objeto do data frame com `data.frame()`

```{r criando df}
df <- data.frame(ouricos = 1:5, peixes = 6:10,crustaceos = 11:15)
df
```
  
Agora podemos acessar os dados utilizando ´$`

```{r checando colunas}
df$peixes
df$ouricos
df$crustaceos
```

Podemos utilizar tambem para executar funções

```{r funcoes no dt}
mean(df$peixes)
sum(df$peixes)
```

Também podemos dar nomes as linhas, se quisermos.

```{r dando nomes as linhas}
rownames(df) <- c("tr1", "tr2", "tr3", "tr4", "tr5")
df
```


### Tibble

* A tibble é uma reformulação moderna dos data frames
    + Mantem o que é mais efetivo e descarta o que não é
    + São data frames “preguiçosos e grosseiros”.– 
        - Fazem menos
        - Reclamam mais
    + Forçam a confrontar estes problemas mais cedo
    + Elas não são encontradas no pacote base. Para utilizarmos precisamos abrir o pacote `tidyverse` ou especificamente o pacote `tibble`


```{r tibble}
df_tbl <-tibble(df)
df_tbl
```

A tibble também possui um aprimoramento no método de "impressão", o que facilita seu uso com com conjuntos de dados grandes, contendo objetos complexos. Para verificar isso podemos utilizar o conjunto de dados `iris`, ja contido no pacote `tibble`. Compare os resultados abaixo.

```{r tibble2}
head(iris, 10) # Aqui solicitamos somente as 10 primeiras linhas
as_tibble(iris)
```
  
Como falamos anteriormente, a `tibble()` faz menos coisas do que o `data.frame()`. Ela nunca troca o tipo dos dados, nunca troca o nome das variáveis e nunca aceita `row.names()`.   
Para verificar isto, podemos utilizar o datase `mtcars` que vem no pacote `datasets` do R base. Neste data frame as linhas vem nomeadas.
```{r}
head(mtcars, 10)
```
  
Repare que as linhas estão com os nomes dos carros.  
Agora vejamos como fica ao criar uma `tibble()`

```{r}
mtcars_tbl <- tibble(mtcars)
mtcars_tbl
```

Os nomes das linhas desapareceram. E são informações importantes. Por isso devemos armazena-los como uma coluna para não perdermos a informação. Isto pode ser facilmente realizado com a função `add_column`. Mas primeiro precisamos criar um vetor contendo os nomes das linhas.

```{r adicionando coluna}
RN <- rownames(mtcars)
add_column(mtcars_tbl, RN)
```

Para conhecermos mais detalhes sobre as tibbles, podemos acessar a ajuda em `vignette("tibble", package = "tibble")`.

  
Podemos também definir uma tibble linha-a-linha com `tribble()`

```{r definindo por tribble}
tribble(
  ~x, ~y,  ~z,
  "a", 2,  3.6,
  "b", 1,  8.5
)
```

## Condicionais
  
Condicionais permitem que seu programa tomar decisões baseadas em testes lógicos. Funcionam como bifurcações no programa. Os testes lógicos utilizam operadores lógicos para controlar o fluxo do programa. Estes operadores lógicos avaliam as variáveis, mas não as modificam. A escolha do use de cada comando condicional esta ligado ao número de condições e de respostas.

  
![Lembrando os operadores lógicos](img/operadores_logicos.png){ width=40% } 
  
No R possui quatro funções básicas para condicionais, `if`, `else`, `else if` e `ifelse`. Cada uma vai ter uma particularidade com relação ao número de condições a serem testadas e a execução do código em função da resposta ser `TRUE` ou `FALSE`. A imagem a seguir ilustra estas diferenças que serão discutidas separadamente nos tópicos a seguir.  
    
  
![Esquema de condicionais](img/condicionais2.png){ width=50% } 
    
    Os condicionais que vamos apresentar podem ser escritos direto em uma linha. No entanto, para facilitar a leitura e entendimento, sugiro que sejam utilizados linhas diferentes e identação para facilitar a visualização do que esta dentro dos condicionais.  
   
### if
  
O `if` indica ao R que ele deve executar uma determinanda tarefa, caso o resultado de um teste lógico resulte em `TRUE`. 
  
```{r definindo x para if}
x <- -5
```

Como o `if` só responde em caso de `TRUE`, ele é um condicional de uma condicao e somente uma resposta. Por isso é utilizado para condições de uma via. No caso do teste lógico retornar `FALSE`, o R vai pular o código e não vai executar nada.

 `if (teste logico) {`  
     `codigo executado se o teste == TRUE`  
 }`
 
 Em inglês a leitura direta do código acima fica mais simples, mas em português podemos ler como: Caso o *teste lógico* seja verdadeiro, execute o código entre chaves.  
 Veja o resultado dos códigos abaixo.

```{r usando if1}
if(x>10){
  print("maior que 10")
}
```


```{r usando if2}
if(x<0){
  x <- x*-1
}
```
   
Nestes casos simples, utilizamos somente uma linha de código. No entanto, o `if` aceita diversas linhas. Veja o código abaixo. Ele vai verificar se o vetor `num` tem mais de um valor associado. Caso não seja um escalar (vetor com um único elemento), o R vai informar que é um vetor com mais de um elemento e vai realizar a média dos valores de `num`. Depois vai retornar uma mensagem de confirmação.


```{r if de varias linhas}
num <- c(1,2,3,4,5)

if(length(num)>1){
  print("Seu vetor não é um escalar")
  print("Vamos obter a média")
  print(mean(num))
  print("Pronto!")
}
```
  No entanto, o `if`só poderá avaliar uma única condição `TRUE` ou `FALSE`. Se você solicitar uma condição que crie um vetor com mais de um `TRUE` ou `FALSE`, uma mensagem de aviso informará que somente o primeiro elemento será usado.  
  Veja o código abaixo, o teste lógico pergunta se os valores dos elementos são >3. Perceba que a resposta é um vetor com uma resposta lógica para cada elemento do vetor.
   
```{r resultado de vetores logicos}
x <- 1:10
x>3
```
   
Agora veja o que acontece quando colocamos este teste lógico na condicional.
  
```{r}
if(num>1){
  print(num)
}
```

### else  
  
Agora imagine que nós queremos que o R também execute alguma ação caso o resultado do teste lógico seja `FALSE`. Para estes casos utilizamos `else` em conjunto com `if`. O `else` funciona como uma extenção do `if` onde podemos incluir o segundo caso. Assim criamos uma condicional de duas vias, onde são executados códigos em função das duas respostas possíveis do teste lógico.
  
`if (teste lógico) {`  
`  Plano A`  
`} else {`  
`  Plano B`  
}
  
Vamos a leitura deste caso. Caso o *teste lógico* seja verdadeiro, execute o *Plano A*. Caso contrario, execute o *Plano B*.
  Vamos ver o código abaixo. Nele pedimos que seja avaliado o objeto `x` e caso seja maior que 10 deve ser retornado `maior que 10`, caso contrário, deve retornar `menor que 10`
    
```{r}
x <- 5

if(x>10){
  print("maior que 10")
} else {
  print("menor que 10")
}

```
  
  
### else if
  
  Em algumas situações, vamos precisar que mais de uma condição seja avaliada. Nestes casos podemos utilizar em conjunto com `if` e `else` o comando `else if`. Este comando é posicionado entre `if` e `else` no código. Você pode utilizar quantos `else if` desejar para aumentar o número de bifurcações no seu código, resultando em mais opções de saída. Reparem que o `else if` tambem vem assocido a uma condição. 
  
`if (condicao1) {`  
`  Plano A`  
`} else if(condicao2){`  
`  Plano B`  
`} else{`  
`  Plano C`  
`}`  

  Neste caso, podemos ler o código da seguinte forma. Caso a *condição1* seja verdadeira, execute o *Plano A*. Caso a *condição2* seja verdadeira, execute o *Plano B*. Caso tanto a *condição1* quanto a *condição2* sejam falsas, execute o *Plano C*.  
  No código abaixo, vamos comparar duas variáveis `a` e `b`. A condicional vai responder caso uma seja maior do que a outra, ou caso sejam iguais. Vejam que temos três possibilides de saída: `a maior do que b`, `b maior do que a` ou `são iguais`.

```{r}
a <- 10
b <- 5

if(a>b){
  print("A é maior que B")
  } else if(a<b){
    print("B é maior que A")
  } else {print("São iguais")}
```




### ifelse

COmo vimos anteriormente, os comandos `if` e `else` não são vetorizados. Por isso, como alternativa temos o comando `ifelse`, que retorna vetores.

`ifelse(condição, TRUE, FALSE)` 

```{r}
num <- 1:10

ifelse(num>3, "<3", ">3")
ifelse(num>3, 1, -1)
```
  
  Repare que não foi necessário indicar a função `print()`, o código retornou o valor indicado em função da resposta ser verdadeira ou falso, para cada elemento do vetor.  
  Como exemplo podemos ver o cógido abaixo, que vai responder se cada elemento do vetor é par ou impar. Para isso vamos utilizar o operador `%%` que nos retorna o resto de uma divisão, neste caso por 2. Se o resto for 0, a resposta é `par`, caso contrário, a resposta é `impar`.
    
```{r}
x <- 1:10
ifelse(x %% 2 == 0, "par", "impar")

```
    

![Modelos de condicionais](img/condicionais.png){ width=100% }


## Loops
    
Os loops são métodos que o R possui para repetir uma tarefa.
  

![Esquemas de loops](img/loop.png)

### for  

Repete o código indicado várias vezes, uma para cada elemento em um conjunto indicado


for (valor in objeto) {
  faca isso
} 

```{r}
for (valor in 1:5){
  print(valor)
}
```




```{r}
texto <- c("use", "R", "pois", "o", "R", "é", "legal")

for(palavra in texto){
  print(palavra)
}
```



### while  

Repete um código enquanto (“while”) uma condição se mantem verdadeira (“TRUE”).

 while (condicao) {
   codigo
 }


x <- 10

while(x<10)

### repeat

Repete o código até que você indique a parada, ou encontrem o comando break

`repeat{`
   `código`
 `}`


```{r usando repeat}
n <- 30

repeat {
  n <- n - 1
  print(n)
  if (n <= 0) {
    break
    }
  }

```





















